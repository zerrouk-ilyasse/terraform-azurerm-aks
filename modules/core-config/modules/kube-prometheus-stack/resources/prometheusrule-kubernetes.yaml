# source - https://github.com/monitoring-mixins/website/blob/master/assets/kubernetes/alerts.yaml
# last commit - 18/09/21
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: kubernetes-monitoring-rules
  namespace: monitoring
  labels:
    lnrs.io/k8s-platform: "true"
    lnrs.io/monitoring-platform: "true"
    lnrs.io/prometheus-rule: "true"
spec:
  groups:
    - name: kubernetes-apps
      rules:
        - alert: KubePodCrashLooping
          annotations:
            description: Pod {{ $labels.namespace }}/{{ $labels.pod }} ({{ $labels.container }}) is restarting {{ printf "%.2f" $value }} times / 10 minutes.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubepodcrashlooping
            summary: Pod is crash looping.
          expr: |
            increase(kube_pod_container_status_restarts_total{job="kube-state-metrics"}[10m]) > 0
            and
            kube_pod_container_status_waiting{job="kube-state-metrics"} == 1
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.container }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            uid: "{{ $labels.uid }}"
            corealert: "true"
        - alert: KubePodNotReady
          annotations:
            description: Pod {{ $labels.namespace }}/{{ $labels.pod }} has been in a non-ready state for longer than 15 minutes.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubepodnotready
            summary: Pod has been in a non-ready state for more than 15 minutes.
          expr: |
            sum by (namespace, pod) (
              max by(namespace, pod) (
                kube_pod_status_phase{job="kube-state-metrics", phase=~"Pending|Unknown"}
              ) * on(namespace, pod) group_left(owner_kind) topk by(namespace, pod) (
                1, max by(namespace, pod, owner_kind) (kube_pod_owner{owner_kind!="Job"})
              )
            ) > 0
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.container }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            uid: "{{ $labels.uid }}"
            phase: "{{ $labels.phase }}"
            corealert: "true"
        - alert: KubeDeploymentGenerationMismatch
          annotations:
            description: Deployment generation for {{ $labels.namespace }}/{{ $labels.deployment }} does not match, this indicates that the Deployment has failed but has not been rolled back.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubedeploymentgenerationmismatch
            summary: Deployment generation mismatch due to possible roll-back
          expr: |
            kube_deployment_status_observed_generation{job="kube-state-metrics"}
              !=
            kube_deployment_metadata_generation{job="kube-state-metrics"}
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            deployment: "{{ $labels.deployment }}"
            endpoint: "{{ $labels.container }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            uid: "{{ $labels.uid }}"
            phase: "{{ $labels.phase }}"
            corealert: "true"
        - alert: KubeDeploymentReplicasMismatch
          annotations:
            description: Deployment {{ $labels.namespace }}/{{ $labels.deployment }} has not matched the expected number of replicas for longer than 15 minutes.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubedeploymentreplicasmismatch
            summary: Deployment has not matched the expected number of replicas.
          expr: |
            (
              kube_deployment_spec_replicas{job="kube-state-metrics"}
                >
              kube_deployment_status_replicas_available{job="kube-state-metrics"}
            ) and (
              changes(kube_deployment_status_replicas_updated{job="kube-state-metrics"}[10m])
                ==
              0
            )
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            deployment: "{{ $labels.deployment }}"
            endpoint: "{{ $labels.container }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeStatefulSetReplicasMismatch
          annotations:
            description: StatefulSet {{ $labels.namespace }}/{{ $labels.statefulset }} has not matched the expected number of replicas for longer than 15 minutes.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubestatefulsetreplicasmismatch
            summary: Deployment has not matched the expected number of replicas.
          expr: |
            (
              kube_statefulset_status_replicas_ready{job="kube-state-metrics"}
                !=
              kube_statefulset_status_replicas{job="kube-state-metrics"}
            ) and (
              changes(kube_statefulset_status_replicas_updated{job="kube-state-metrics"}[10m])
                ==
              0
            )
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            statefulset: "{{ $labels.statefulset }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeStatefulSetGenerationMismatch
          annotations:
            description: StatefulSet generation for {{ $labels.namespace }}/{{ $labels.statefulset }} does not match, this indicates that the StatefulSet has failed but has not been rolled back.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubestatefulsetgenerationmismatch
            summary: StatefulSet generation mismatch due to possible roll-back
          expr: |
            kube_statefulset_status_observed_generation{job="kube-state-metrics"}
              !=
            kube_statefulset_metadata_generation{job="kube-state-metrics"}
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            statefulset: "{{ $labels.statefulset }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeStatefulSetUpdateNotRolledOut
          annotations:
            description: StatefulSet {{ $labels.namespace }}/{{ $labels.statefulset }} update has not been rolled out.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubestatefulsetupdatenotrolledout
            summary: StatefulSet update has not been rolled out.
          expr: |
            (
              max without (revision) (
                kube_statefulset_status_current_revision{job="kube-state-metrics"}
                  unless
                kube_statefulset_status_update_revision{job="kube-state-metrics"}
              )
                *
              (
                kube_statefulset_replicas{job="kube-state-metrics"}
                  !=
                kube_statefulset_status_replicas_updated{job="kube-state-metrics"}
              )
            )  and (
              changes(kube_statefulset_status_replicas_updated{job="kube-state-metrics"}[5m])
                ==
              0
            )
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            revision: "{{ $labels.revision }}"
            statefulset: "{{ $labels.statefulset }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeDaemonSetRolloutStuck
          annotations:
            description: DaemonSet {{ $labels.namespace }}/{{ $labels.daemonset }} has not finished or progressed for at least 15 minutes.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubedaemonsetrolloutstuck
            summary: DaemonSet rollout is stuck.
          expr: |
            (
              (
                kube_daemonset_status_current_number_scheduled{job="kube-state-metrics"}
                 !=
                kube_daemonset_status_desired_number_scheduled{job="kube-state-metrics"}
              ) or (
                kube_daemonset_status_number_misscheduled{job="kube-state-metrics"}
                 !=
                0
              ) or (
                kube_daemonset_updated_number_scheduled{job="kube-state-metrics"}
                 !=
                kube_daemonset_status_desired_number_scheduled{job="kube-state-metrics"}
              ) or (
                kube_daemonset_status_number_available{job="kube-state-metrics"}
                 !=
                kube_daemonset_status_desired_number_scheduled{job="kube-state-metrics"}
              )
            ) and (
              changes(kube_daemonset_updated_number_scheduled{job="kube-state-metrics"}[5m])
                ==
              0
            )
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            daemonset: "{{ $labels.daemonset }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeContainerWaiting
          annotations:
            description: Pod {{ $labels.namespace }}/{{ $labels.pod }} container {{ $labels.container}} has been in waiting state for longer than 1 hour.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubecontainerwaiting
            summary: Pod container waiting longer than 1 hour
          expr: |
            sum by (namespace, pod, container) (kube_pod_container_status_waiting_reason{job="kube-state-metrics"}) > 0
          for: 1h
          labels:
            severity: warning
            corealert: "true"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            container: "{{ $labels.container }}"
        - alert: KubeDaemonSetNotScheduled
          annotations:
            description: "{{ $value }} Pods of DaemonSet {{ $labels.namespace }}/{{ $labels.daemonset }} are not scheduled."
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubedaemonsetnotscheduled
            summary: DaemonSet pods are not scheduled.
          expr: |
            kube_daemonset_status_desired_number_scheduled{job="kube-state-metrics"}
              -
            kube_daemonset_status_current_number_scheduled{job="kube-state-metrics"} > 0
          for: 10m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            daemonset: "{{ $labels.daemonset }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeDaemonSetMisScheduled
          annotations:
            description: "{{ $value }} Pods of DaemonSet {{ $labels.namespace }}/{{ $labels.daemonset }} are running where they are not supposed to run."
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubedaemonsetmisscheduled
            summary: DaemonSet pods are misscheduled.
          expr: |
            kube_daemonset_status_number_misscheduled{job="kube-state-metrics"} > 0
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            daemonset: "{{ $labels.daemonset }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeJobCompletion
          annotations:
            description: Job {{ $labels.namespace }}/{{ $labels.job_name }} is taking more than 12 hours to complete.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubejobcompletion
            summary: Job did not complete in time
          expr: |
            kube_job_spec_completions{job="kube-state-metrics"} - kube_job_status_succeeded{job="kube-state-metrics"}  > 0
          for: 12h
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            job_name: "{{ $labels.job_name }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeJobFailed
          annotations:
            description: Job {{ $labels.namespace }}/{{ $labels.job_name }} failed to complete. Removing failed job after investigation should clear this alert.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubejobfailed
            summary: Job failed to complete.
          expr: |
            kube_job_failed{job="kube-state-metrics"}  > 0
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            job_name: "{{ $labels.job_name }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeHpaReplicasMismatch
          annotations:
            description: HPA {{ $labels.namespace }}/{{ $labels.horizontalpodautoscaler  }} has not matched the desired number of replicas for longer than 15 minutes.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubehpareplicasmismatch
            summary: HPA has not matched descired number of replicas.
          expr: |
            (kube_horizontalpodautoscaler_status_desired_replicas{job="kube-state-metrics"}
              !=
            kube_horizontalpodautoscaler_status_current_replicas{job="kube-state-metrics"})
              and
            (kube_horizontalpodautoscaler_status_current_replicas{job="kube-state-metrics"}
              >
            kube_horizontalpodautoscaler_spec_min_replicas{job="kube-state-metrics"})
              and
            (kube_horizontalpodautoscaler_status_current_replicas{job="kube-state-metrics"}
              <
            kube_horizontalpodautoscaler_spec_max_replicas{job="kube-state-metrics"})
              and
            changes(kube_horizontalpodautoscaler_status_current_replicas{job="kube-state-metrics"}[15m]) == 0
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            horizontalpodautoscaler: "{{ $labels.horizontalpodautoscaler }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeHpaMaxedOut
          annotations:
            description: HPA {{ $labels.namespace }}/{{ $labels.horizontalpodautoscaler  }} has been running at max replicas for longer than 15 minutes.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubehpamaxedout
            summary: HPA is running at max replicas
          expr: |
            kube_horizontalpodautoscaler_status_current_replicas{job="kube-state-metrics"}
              ==
            kube_horizontalpodautoscaler_spec_max_replicas{job="kube-state-metrics"}
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            horizontalpodautoscaler: "{{ $labels.horizontalpodautoscaler }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            corealert: "true"
    - name: kubernetes-resources
      rules:
        - alert: KubeCPUOvercommit
          annotations:
            description: Cluster has overcommitted CPU resource requests for Pods by {{ $value }} CPU shares and cannot tolerate node failure.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubecpuovercommit
            summary: Cluster has overcommitted CPU resource requests.
          expr: |
            sum(namespace_cpu:kube_pod_container_resource_requests:sum{}) - (sum(kube_node_status_allocatable{resource="cpu"}) - max(kube_node_status_allocatable{resource="cpu"})) > 0
            and
            (sum(kube_node_status_allocatable{resource="cpu"}) - max(kube_node_status_allocatable{resource="cpu"})) > 0
          for: 10m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            node: "{{ $labels.node }}"
            pod: "{{ $labels.pod }}"
            resource: "{{ $labels.resource }}"
            service: "{{ $labels.service }}"
            unit: "{{ $labels.unit }}"
            corealert: "true"
        - alert: KubeMemoryOvercommit
          annotations:
            description: Cluster has overcommitted memory resource requests for Pods by {{ $value }} bytes and cannot tolerate node failure.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubememoryovercommit
            summary: Cluster has overcommitted memory resource requests.
          expr: |
            sum(namespace_memory:kube_pod_container_resource_requests:sum{}) - (sum(kube_node_status_allocatable{resource="memory"}) - max(kube_node_status_allocatable{resource="memory"})) > 0
            and
            (sum(kube_node_status_allocatable{resource="memory"}) - max(kube_node_status_allocatable{resource="memory"})) > 0
          for: 10m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            node: "{{ $labels.node }}"
            pod: "{{ $labels.pod }}"
            resource: "{{ $labels.resource }}"
            service: "{{ $labels.service }}"
            unit: "{{ $labels.unit }}"
            corealert: "true"
        - alert: KubeCPUQuotaOvercommit
          annotations:
            description: Cluster has overcommitted CPU resource requests for Namespaces.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubecpuquotaovercommit
            summary: Cluster has overcommitted CPU resource requests.
          expr: |
            sum(kube_resourcequota{job="kube-state-metrics", type="hard", resource="cpu"})
              /
            sum(kube_node_status_allocatable{resource="cpu"})
              > 1.5
          for: 5m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            node: "{{ $labels.node }}"
            pod: "{{ $labels.pod }}"
            resource: "{{ $labels.resource }}"
            service: "{{ $labels.service }}"
            unit: "{{ $labels.unit }}"
            corealert: "true"
        - alert: KubeMemoryQuotaOvercommit
          annotations:
            description: Cluster has overcommitted memory resource requests for Namespaces.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubememoryquotaovercommit
            summary: Cluster has overcommitted memory resource requests.
          expr: |
            sum(kube_resourcequota{job="kube-state-metrics", type="hard", resource="memory"})
              /
            sum(kube_node_status_allocatable{resource="memory",job="kube-state-metrics"})
              > 1.5
          for: 5m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            node: "{{ $labels.node }}"
            pod: "{{ $labels.pod }}"
            resource: "{{ $labels.resource }}"
            service: "{{ $labels.service }}"
            unit: "{{ $labels.unit }}"
            corealert: "true"
        - alert: KubeQuotaAlmostFull
          annotations:
            description: Namespace {{ $labels.namespace }} is using {{ $value | humanizePercentage }} of its {{ $labels.resource }} quota.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubequotaalmostfull
            summary: Namespace quota is going to be full.
          expr: |
            kube_resourcequota{job="kube-state-metrics", type="used"}
              / ignoring(instance, job, type)
            (kube_resourcequota{job="kube-state-metrics", type="hard"} > 0)
              > 0.9 < 1
          for: 15m
          labels:
            severity: info
            corealert: "true"
            namespace: "{{ $labels.namespace }}"
            resource: "{{ $labels.resource }}"
        - alert: KubeQuotaFullyUsed
          annotations:
            description: Namespace {{ $labels.namespace }} is using {{ $value | humanizePercentage }} of its {{ $labels.resource }} quota.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubequotafullyused
            summary: Namespace quota is fully used.
          expr: |
            kube_resourcequota{job="kube-state-metrics", type="used"}
              / ignoring(instance, job, type)
            (kube_resourcequota{job="kube-state-metrics", type="hard"} > 0)
              == 1
          for: 15m
          labels:
            severity: info
            corealert: "true"
            namespace: "{{ $labels.namespace }}"
            resource: "{{ $labels.resource }}"
        - alert: KubeQuotaExceeded
          annotations:
            description: Namespace {{ $labels.namespace }} is using {{ $value | humanizePercentage }} of its {{ $labels.resource }} quota.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubequotaexceeded
            summary: Namespace quota has exceeded the limits.
          expr: |
            kube_resourcequota{job="kube-state-metrics", type="used"}
              / ignoring(instance, job, type)
            (kube_resourcequota{job="kube-state-metrics", type="hard"} > 0)
              > 1
          for: 15m
          labels:
            severity: warning
            corealert: "true"
            namespace: "{{ $labels.namespace }}"
            resource: "{{ $labels.resource }}"
        - alert: CPUThrottlingHigh
          annotations:
            description: "{{ $value | humanizePercentage }} throttling of CPU in namespace {{ $labels.namespace }} for container {{ $labels.container }} in pod {{ $labels.pod }}."
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/cputhrottlinghigh
            summary: Processes experience elevated CPU throttling.
          expr: |
            sum(increase(container_cpu_cfs_throttled_periods_total{container!="", }[5m])) by (container, pod, namespace)
              /
            sum(increase(container_cpu_cfs_periods_total{}[5m])) by (container, pod, namespace)
              > ( 25 / 100 )
          for: 15m
          labels:
            severity: info
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            job: "{{ $labels.container }}"
            id: "{{ $labels.id }}"
            image: "{{ $labels.image }}"
            namespace: "{{ $labels.namespace }}"
            metrics_path: "{{ $labels.metrics_path }}"
            name: "{{ $labels.name }}"
            node: "{{ $labels.node }}"
            pod: "{{ $labels.pod }}"
            resource: "{{ $labels.resource }}"
            service: "{{ $labels.service }}"
            unit: "{{ $labels.unit }}"
            corealert: "true"
    - name: kubernetes-storage
      rules:
        - alert: KubePersistentVolumeFillingUp
          annotations:
            description: The PersistentVolume claimed by {{ $labels.persistentvolumeclaim }} in Namespace {{ $labels.namespace }} is only {{ $value | humanizePercentage }} free.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubepersistentvolumefillingup
            summary: PersistentVolume is filling up.
          expr: |
            (
              kubelet_volume_stats_available_bytes{job="kubelet", metrics_path="/metrics"}
                /
              kubelet_volume_stats_capacity_bytes{job="kubelet", metrics_path="/metrics"}
            ) < 0.03
            and
            kubelet_volume_stats_used_bytes{job="kubelet", metrics_path="/metrics"} > 0
          for: 1m
          labels:
            severity: critical
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            metrics_path: "{{ $labels.metrics_path }}"
            namespace: "{{ $labels.namespace }}"
            node: "{{ $labels.node }}"
            persistentvolumeclaim: "{{ $labels.persistentvolumeclaim }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubePersistentVolumeFillingUp
          annotations:
            description: Based on recent sampling, the PersistentVolume claimed by {{ $labels.persistentvolumeclaim }} in Namespace {{ $labels.namespace }} is expected to fill up within four days. Currently {{ $value | humanizePercentage }} is available.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubepersistentvolumefillingup
            summary: PersistentVolume is filling up.
          expr: |
            (
              kubelet_volume_stats_available_bytes{job="kubelet", metrics_path="/metrics"}
                /
              kubelet_volume_stats_capacity_bytes{job="kubelet", metrics_path="/metrics"}
            ) < 0.15
            and
            kubelet_volume_stats_used_bytes{job="kubelet", metrics_path="/metrics"} > 0
            and
            predict_linear(kubelet_volume_stats_available_bytes{job="kubelet", metrics_path="/metrics"}[6h], 4 * 24 * 3600) < 0
          for: 1h
          labels:
            severity: warning
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            metrics_path: "{{ $labels.metrics_path }}"
            namespace: "{{ $labels.namespace }}"
            node: "{{ $labels.node }}"
            persistentvolumeclaim: "{{ $labels.persistentvolumeclaim }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubePersistentVolumeErrors
          annotations:
            description: The persistent volume {{ $labels.persistentvolume }} has status {{ $labels.phase }}.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubepersistentvolumeerrors
            summary: PersistentVolume is having issues with provisioning.
          expr: |
            kube_persistentvolume_status_phase{phase=~"Failed|Pending",job="kube-state-metrics"} > 0
          for: 5m
          labels:
            severity: critical
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            metrics_path: "{{ $labels.metrics_path }}"
            namespace: "{{ $labels.namespace }}"
            node: "{{ $labels.node }}"
            persistentvolumeclaim: "{{ $labels.persistentvolumeclaim }}"
            phase: "{{ $labels.phase }}"
            service: "{{ $labels.service }}"
            corealert: "true"
    - name: kubernetes-system
      rules:
        - alert: KubeVersionMismatch
          annotations:
            description: There are {{ $value }} different semantic versions of Kubernetes components running.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeversionmismatch
            summary: Different semantic versions of Kubernetes components running.
          expr: |
            count(count by (git_version) (label_replace(kubernetes_build_info{job!~"kube-dns|coredns"},"git_version","$1","git_version","(v[0-9]*.[0-9]*).*"))) > 1
          for: 15m
          labels:
            severity: warning
            corealert: "true"
        - alert: KubeClientErrors
          annotations:
            description: Kubernetes API server client '{{ $labels.job }}/{{ $labels.instance }}' is experiencing {{ $value | humanizePercentage }} errors.'
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeclienterrors
            summary: Kubernetes API server client is experiencing errors.
          expr: |
            (sum(rate(rest_client_requests_total{code=~"5.."}[5m])) by (instance, job, namespace)
              /
            sum(rate(rest_client_requests_total[5m])) by (instance, job, namespace))
            > 0.01
          for: 15m
          labels:
            severity: warning
            code: "{{ $labels.code }}"
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            host: "{{ $labels.host }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            node: "{{ $labels.node }}"
            method: "{{ $labels.method }}"
            phase: "{{ $labels.phase }}"
            service: "{{ $labels.service }}"
            pod: "{{ $labels.pod }}"
            corealert: "true"
    - name: kube-apiserver-slos
      rules:
        - alert: KubeAPIErrorBudgetBurn
          annotations:
            description: The API server is burning too much error budget.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeapierrorbudgetburn
            summary: The API server is burning too much error budget.
          expr: |
            sum(apiserver_request:burnrate1h) > (14.40 * 0.01000)
            and
            sum(apiserver_request:burnrate5m) > (14.40 * 0.01000)
          for: 2m
          labels:
            #long: 1h
            severity: critical
            corealert: "true"
            #short: 5m
        - alert: KubeAPIErrorBudgetBurn
          annotations:
            description: The API server is burning too much error budget.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeapierrorbudgetburn
            summary: The API server is burning too much error budget.
          expr: |
            sum(apiserver_request:burnrate6h) > (6.00 * 0.01000)
            and
            sum(apiserver_request:burnrate30m) > (6.00 * 0.01000)
          for: 15m
          labels:
            #long: 6h
            severity: critical
            corealert: "true"
            #short: 30m
        - alert: KubeAPIErrorBudgetBurn
          annotations:
            description: The API server is burning too much error budget.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeapierrorbudgetburn
            summary: The API server is burning too much error budget.
          expr: |
            sum(apiserver_request:burnrate1d) > (3.00 * 0.01000)
            and
            sum(apiserver_request:burnrate2h) > (3.00 * 0.01000)
          for: 1h
          labels:
            long: 1d
            severity: warning
            corealert: "true"
            short: 2h
    - name: kubernetes-system-apiserver
      rules:
        - alert: KubeClientCertificateExpiration
          annotations:
            description: A client certificate used to authenticate to the apiserver is expiring in less than 7.0 days.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeclientcertificateexpiration
            summary: Client certificate is about to expire.
          expr: |
            apiserver_client_certificate_expiration_seconds_count{job="apiserver"} > 0 and on(job) histogram_quantile(0.01, sum by (job, le) (rate(apiserver_client_certificate_expiration_seconds_bucket{job="apiserver"}[5m]))) < 604800
          labels:
            severity: warning
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeClientCertificateExpiration
          annotations:
            description: A client certificate used to authenticate to the apiserver is expiring in less than 24.0 hours.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeclientcertificateexpiration
            summary: Client certificate is about to expire.
          expr: |
            apiserver_client_certificate_expiration_seconds_count{job="apiserver"} > 0 and on(job) histogram_quantile(0.01, sum by (job, le) (rate(apiserver_client_certificate_expiration_seconds_bucket{job="apiserver"}[5m]))) < 86400
          labels:
            severity: critical
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            namespace: "{{ $labels.namespace }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: AggregatedAPIErrors
          annotations:
            description: An aggregated API {{ $labels.name }}/{{ $labels.namespace }} has reported errors. It has appeared unavailable {{ $value | humanize }} times averaged over the past 10m.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/aggregatedapierrors
            summary: An aggregated API has reported errors.
          expr: |
            sum by(name, namespace)(increase(aggregator_unavailable_apiservice_total[10m])) > 4
          labels:
            severity: warning
            corealert: "true"
        - alert: AggregatedAPIDown
          annotations:
            description: An aggregated API {{ $labels.name }}/{{ $labels.namespace }} has been only {{ $value | humanize }}% available over the last 10m.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/aggregatedapidown
            summary: An aggregated API is down.
          expr: |
            (1 - max by(name, namespace)(avg_over_time(aggregator_unavailable_apiservice[10m]))) * 100 < 85
          for: 5m
          labels:
            severity: warning
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.container }}"
            name: "{{ $labels.name }}"
            namespace: "{{ $labels.namespace }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeAPIDown
          annotations:
            description: KubeAPI has disappeared from Prometheus target discovery.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeapidown
            summary: Target disappeared from Prometheus target discovery.
          expr: |
            absent(up{job="apiserver"} == 1)
          for: 15m
          labels:
            severity: critical
            corealert: "true"
        - alert: KubeAPITerminatedRequests
          annotations:
            description: The apiserver has terminated {{ $value | humanizePercentage }} of its incoming requests.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeapiterminatedrequests
            summary: The apiserver has terminated {{ $value | humanizePercentage }} of its incoming requests.
          expr: |
            sum(rate(apiserver_request_terminations_total{job="apiserver"}[10m]))  / (  sum(rate(apiserver_request_total{job="apiserver"}[10m])) + sum(rate(apiserver_request_terminations_total{job="apiserver"}[10m])) ) > 0.20
          for: 5m
          labels:
            severity: warning
            code: "{{ $labels.code }}"
            component: "{{ $labels.component }}"
            endpoint: "{{ $labels.endpoint }}"
            group: "{{ $labels.group }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.job }}"
            namespace: "{{ $labels.namespace }}"
            resource: "{{ $labels.resource }}"
            scope: "{{ $labels.scope }}"
            service: "{{ $labels.service }}"
            verb: "{{ $labels.verb }}"
            version: "{{ $labels.version }}"
            corealert: "true"
    - name: kubernetes-system-kubelet
      rules:
        - alert: KubeNodeNotReady
          annotations:
            description: "{{ $labels.node }} has been unready for more than 15 minutes."
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubenodenotready
            summary: Node is not ready.
          expr: |
            kube_node_status_condition{job="kube-state-metrics",condition="Ready",status="true"} == 0
          for: 15m
          labels:
            severity: warning
            condition: "{{ $labels.condition }}"
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.job }}"
            namespace: "{{ $labels.namespace }}"
            node: "{{ $labels.node }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            status: "{{ $labels.status }}"
            corealert: "true"
        - alert: KubeNodeUnreachable
          annotations:
            description: "{{ $labels.node }} is unreachable and some workloads may be rescheduled."
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubenodeunreachable
            summary: Node is unreachable.
          expr: |
            (kube_node_spec_taint{job="kube-state-metrics",key="node.kubernetes.io/unreachable",effect="NoSchedule"} unless ignoring(key,value) kube_node_spec_taint{job="kube-state-metrics",key=~"ToBeDeletedByClusterAutoscaler|cloud.google.com/impending-node-termination|aws-node-termination-handler/spot-itn"}) == 1
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            effect: "{{ $labels.effects }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.job }}"
            key: "{{ $labels.key }}"
            namespace: "{{ $labels.namepace }}"
            node: "{{ $labels.node }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            value: "{{ $labels.value }}"
            corealert: "true"
        - alert: KubeletTooManyPods
          annotations:
            description: Kubelet '{{ $labels.node }}' is running at {{ $value | humanizePercentage }} of its Pod capacity.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubelettoomanypods
            summary: Kubelet is running at capacity.
          expr: |
            count by(node) (
              (kube_pod_status_phase{job="kube-state-metrics",phase="Running"} == 1) * on(instance,pod,namespace,cluster) group_left(node) topk by(instance,pod,namespace,cluster) (1, kube_pod_info{job="kube-state-metrics"})
            )
            /
            max by(node) (
              kube_node_status_capacity{job="kube-state-metrics",resource="pods"} != 1
            ) > 0.95
          for: 15m
          labels:
            severity: info
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.job }}"
            namespace: "{{ $labels.namepace }}"
            node: "{{ $labels.node }}"
            phase: "{{ $labels.phase }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            uid: "{{ $labels.uid }}"
            corealert: "true"
        - alert: KubeNodeReadinessFlapping
          annotations:
            description: The readiness status of node {{ $labels.node }} has changed {{ $value }} times in the last 15 minutes.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubenodereadinessflapping
            summary: Node readiness status is flapping.
          expr: |
            sum(changes(kube_node_status_condition{status="true",condition="Ready"}[15m])) by (node) > 2
          for: 15m
          labels:
            severity: warning
            container: "{{ $labels.container }}"
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            condition: "{{ $labels.condition }}"
            namespace: "{{ $labels.namepace }}"
            node: "{{ $labels.node }}"
            pod: "{{ $labels.pod }}"
            service: "{{ $labels.service }}"
            status: "{{ $labels.status }}"
            corealert: "true"
        - alert: KubeletPlegDurationHigh
          annotations:
            description: The Kubelet Pod Lifecycle Event Generator has a 99th percentile duration of {{ $value }} seconds on node {{ $labels.node }}.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeletplegdurationhigh
            summary: Kubelet Pod Lifecycle Event Generator is taking too long to relist.
          expr: |
            node_quantile:kubelet_pleg_relist_duration_seconds:histogram_quantile{quantile="0.99"} >= 10
          for: 5m
          labels:
            severity: warning
            corealert: "true"
        - alert: KubeletPodStartUpLatencyHigh
          annotations:
            description: Kubelet Pod startup 99th percentile latency is {{ $value }} seconds on node {{ $labels.node }}.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeletpodstartuplatencyhigh
            summary: Kubelet Pod startup latency is too high.
          expr: |
            histogram_quantile(0.99, sum(rate(kubelet_pod_worker_duration_seconds_bucket{job="kubelet", metrics_path="/metrics"}[5m])) by (instance, le)) * on(instance) group_left(node) kubelet_node_name{job="kubelet", metrics_path="/metrics"} > 60
          for: 15m
          labels:
            severity: warning
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.job }}"
            le: "{{ $labels.le }}"
            metrics_path: "{{ $labels.metrics_path }}"
            namespace: "{{ $labels.namespace }}"
            node: "{{ $labels.node }}"
            operation_type: "{{ $labels.operation_type }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeletClientCertificateExpiration
          annotations:
            description: Client certificate for Kubelet on node {{ $labels.node }} expires in {{ $value | humanizeDuration }}.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeletclientcertificateexpiration
            summary: Kubelet client certificate is about to expire.
          expr: |
            kubelet_certificate_manager_client_ttl_seconds < 604800
          labels:
            severity: warning
            corealert: "true"
        - alert: KubeletClientCertificateExpiration
          annotations:
            description: Client certificate for Kubelet on node {{ $labels.node }} expires in {{ $value | humanizeDuration }}.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeletclientcertificateexpiration
            summary: Kubelet client certificate is about to expire.
          expr: |
            kubelet_certificate_manager_client_ttl_seconds < 86400
          labels:
            severity: critical
            corealert: "true"
        - alert: KubeletServerCertificateExpiration
          annotations:
            description: Server certificate for Kubelet on node {{ $labels.node }} expires in {{ $value | humanizeDuration }}.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeletservercertificateexpiration
            summary: Kubelet server certificate is about to expire.
          expr: |
            kubelet_certificate_manager_server_ttl_seconds < 604800
          labels:
            severity: warning
            corealert: "true"
        - alert: KubeletServerCertificateExpiration
          annotations:
            description: Server certificate for Kubelet on node {{ $labels.node }} expires in {{ $value | humanizeDuration }}.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeletservercertificateexpiration
            summary: Kubelet server certificate is about to expire.
          expr: |
            kubelet_certificate_manager_server_ttl_seconds < 86400
          labels:
            severity: critical
            corealert: "true"
        - alert: KubeletClientCertificateRenewalErrors
          annotations:
            description: Kubelet on node {{ $labels.node }} has failed to renew its client certificate ({{ $value | humanize }} errors in the last 5 minutes).
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeletclientcertificaterenewalerrors
            summary: Kubelet has failed to renew its client certificate.
          expr: |
            increase(kubelet_certificate_manager_client_expiration_renew_errors[5m]) > 0
          for: 15m
          labels:
            severity: warning
            corealert: "true"
        - alert: KubeletServerCertificateRenewalErrors
          annotations:
            description: Kubelet on node {{ $labels.node }} has failed to renew its server certificate ({{ $value | humanize }} errors in the last 5 minutes).
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeletservercertificaterenewalerrors
            summary: Kubelet has failed to renew its server certificate.
          expr: |
            increase(kubelet_server_expiration_renew_errors[5m]) > 0
          for: 15m
          labels:
            severity: warning
            endpoint: "{{ $labels.endpoint }}"
            instance: "{{ $labels.instance }}"
            job: "{{ $labels.job }}"
            metrics_path: "{{ $labels.metrics_path }}"
            namespace: "{{ $labels.namespace }}"
            node: "{{ $labels.node }}"
            service: "{{ $labels.service }}"
            corealert: "true"
        - alert: KubeletDown
          annotations:
            description: Kubelet has disappeared from Prometheus target discovery.
            runbook_url: https://runbooks.prometheus-operator.dev/runbooks/kubernetes/kubeletdown
            summary: Target disappeared from Prometheus target discovery.
          expr: |
            absent(up{job="kubelet", metrics_path="/metrics"} == 1)
          for: 15m
          labels:
            severity: critical
            corealert: "true"
    - name: kube-apiserver-burnrate.rules
      rules:
        - expr: |
            (
              (
                # too slow
                sum by (cluster) (rate(apiserver_request_duration_seconds_count{job="apiserver",verb=~"LIST|GET"}[1h]))
                -
                (
                  (
                    sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"LIST|GET",scope=~"resource|",le="1"}[1h]))
                    or
                    vector(0)
                  )
                  +
                  sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"LIST|GET",scope="namespace",le="5"}[1h]))
                  +
                  sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"LIST|GET",scope="cluster",le="40"}[1h]))
                )
              )
              +
              # errors
              sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"LIST|GET",code=~"5.."}[1h]))
            )
            /
            sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"LIST|GET"}[1h]))
          labels:
            verb: read
          record: apiserver_request:burnrate1h
        - expr: |
            (
              (
                # too slow
                sum by (cluster) (rate(apiserver_request_duration_seconds_count{job="apiserver",verb=~"LIST|GET"}[2h]))
                -
                (
                  (
                    sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"LIST|GET",scope=~"resource|",le="1"}[2h]))
                    or
                    vector(0)
                  )
                  +
                  sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"LIST|GET",scope="namespace",le="5"}[2h]))
                  +
                  sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"LIST|GET",scope="cluster",le="40"}[2h]))
                )
              )
              +
              # errors
              sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"LIST|GET",code=~"5.."}[2h]))
            )
            /
            sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"LIST|GET"}[2h]))
          labels:
            verb: read
          record: apiserver_request:burnrate2h
        - expr: |
            (
              (
                # too slow
                sum by (cluster) (rate(apiserver_request_duration_seconds_count{job="apiserver",verb=~"LIST|GET"}[30m]))
                -
                (
                  (
                    sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"LIST|GET",scope=~"resource|",le="1"}[30m]))
                    or
                    vector(0)
                  )
                  +
                  sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"LIST|GET",scope="namespace",le="5"}[30m]))
                  +
                  sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"LIST|GET",scope="cluster",le="40"}[30m]))
                )
              )
              +
              # errors
              sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"LIST|GET",code=~"5.."}[30m]))
            )
            /
            sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"LIST|GET"}[30m]))
          labels:
            verb: read
          record: apiserver_request:burnrate30m
        - expr: |
            (
              (
                # too slow
                sum by (cluster) (rate(apiserver_request_duration_seconds_count{job="apiserver",verb=~"LIST|GET"}[5m]))
                -
                (
                  (
                    sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"LIST|GET",scope=~"resource|",le="1"}[5m]))
                    or
                    vector(0)
                  )
                  +
                  sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"LIST|GET",scope="namespace",le="5"}[5m]))
                  +
                  sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"LIST|GET",scope="cluster",le="40"}[5m]))
                )
              )
              +
              # errors
              sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"LIST|GET",code=~"5.."}[5m]))
            )
            /
            sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"LIST|GET"}[5m]))
          labels:
            verb: read
          record: apiserver_request:burnrate5m
        - expr: |
            (
              (
                # too slow
                sum by (cluster) (rate(apiserver_request_duration_seconds_count{job="apiserver",verb=~"POST|PUT|PATCH|DELETE"}[1h]))
                -
                sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"POST|PUT|PATCH|DELETE",le="1"}[1h]))
              )
              +
              sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"POST|PUT|PATCH|DELETE",code=~"5.."}[1h]))
            )
            /
            sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"POST|PUT|PATCH|DELETE"}[1h]))
          labels:
            verb: write
          record: apiserver_request:burnrate1h
        - expr: |
            (
              (
                # too slow
                sum by (cluster) (rate(apiserver_request_duration_seconds_count{job="apiserver",verb=~"POST|PUT|PATCH|DELETE"}[2h]))
                -
                sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"POST|PUT|PATCH|DELETE",le="1"}[2h]))
              )
              +
              sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"POST|PUT|PATCH|DELETE",code=~"5.."}[2h]))
            )
            /
            sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"POST|PUT|PATCH|DELETE"}[2h]))
          labels:
            verb: write
          record: apiserver_request:burnrate2h
        - expr: |
            (
              (
                # too slow
                sum by (cluster) (rate(apiserver_request_duration_seconds_count{job="apiserver",verb=~"POST|PUT|PATCH|DELETE"}[30m]))
                -
                sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"POST|PUT|PATCH|DELETE",le="1"}[30m]))
              )
              +
              sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"POST|PUT|PATCH|DELETE",code=~"5.."}[30m]))
            )
            /
            sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"POST|PUT|PATCH|DELETE"}[30m]))
          labels:
            verb: write
          record: apiserver_request:burnrate30m
        - expr: |
            (
              (
                # too slow
                sum by (cluster) (rate(apiserver_request_duration_seconds_count{job="apiserver",verb=~"POST|PUT|PATCH|DELETE"}[5m]))
                -
                sum by (cluster) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"POST|PUT|PATCH|DELETE",le="1"}[5m]))
              )
              +
              sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"POST|PUT|PATCH|DELETE",code=~"5.."}[5m]))
            )
            /
            sum by (cluster) (rate(apiserver_request_total{job="apiserver",verb=~"POST|PUT|PATCH|DELETE"}[5m]))
          labels:
            verb: write
          record: apiserver_request:burnrate5m
    - name: kube-apiserver-histogram.rules
      rules:
        - expr: |
            histogram_quantile(0.99, sum by (cluster, le, resource) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"LIST|GET"}[5m]))) > 0
          labels:
            quantile: "0.99"
            verb: read
          record: cluster_quantile:apiserver_request_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.99, sum by (cluster, le, resource) (rate(apiserver_request_duration_seconds_bucket{job="apiserver",verb=~"POST|PUT|PATCH|DELETE"}[5m]))) > 0
          labels:
            quantile: "0.99"
            verb: write
          record: cluster_quantile:apiserver_request_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.99, sum(rate(apiserver_request_duration_seconds_bucket{job="apiserver",subresource!="log",verb!~"LIST|WATCH|WATCHLIST|DELETECOLLECTION|PROXY|CONNECT"}[5m])) without(instance, pod))
          labels:
            quantile: "0.99"
          record: cluster_quantile:apiserver_request_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.9, sum(rate(apiserver_request_duration_seconds_bucket{job="apiserver",subresource!="log",verb!~"LIST|WATCH|WATCHLIST|DELETECOLLECTION|PROXY|CONNECT"}[5m])) without(instance, pod))
          labels:
            quantile: "0.9"
          record: cluster_quantile:apiserver_request_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.5, sum(rate(apiserver_request_duration_seconds_bucket{job="apiserver",subresource!="log",verb!~"LIST|WATCH|WATCHLIST|DELETECOLLECTION|PROXY|CONNECT"}[5m])) without(instance, pod))
          labels:
            quantile: "0.5"
          record: cluster_quantile:apiserver_request_duration_seconds:histogram_quantile
    - interval: 3m
      name: kube-apiserver-availability.rules
      rules:
        - expr: |
            sum by (cluster, verb, scope) (increase(apiserver_request_duration_seconds_count[1h]))
          record: cluster_verb_scope:apiserver_request_duration_seconds_count:increase1h
        - expr: |
            sum by (cluster, verb, scope, le) (increase(apiserver_request_duration_seconds_bucket[1h]))
          record: cluster_verb_scope_le:apiserver_request_duration_seconds_bucket:increase1h
        - expr: |
            sum by (cluster,code,resource) (rate(apiserver_request_total{job="apiserver",verb=~"LIST|GET"}[5m]))
          labels:
            verb: read
          record: code_resource:apiserver_request_total:rate5m
        - expr: |
            sum by (cluster,code,resource) (rate(apiserver_request_total{job="apiserver",verb=~"POST|PUT|PATCH|DELETE"}[5m]))
          labels:
            verb: write
          record: code_resource:apiserver_request_total:rate5m
        - expr: |
            sum by (cluster, code, verb) (increase(apiserver_request_total{job="apiserver",verb=~"LIST|GET|POST|PUT|PATCH|DELETE",code=~"2.."}[1h]))
          record: code_verb:apiserver_request_total:increase1h
        - expr: |
            sum by (cluster, code, verb) (increase(apiserver_request_total{job="apiserver",verb=~"LIST|GET|POST|PUT|PATCH|DELETE",code=~"3.."}[1h]))
          record: code_verb:apiserver_request_total:increase1h
        - expr: |
            sum by (cluster, code, verb) (increase(apiserver_request_total{job="apiserver",verb=~"LIST|GET|POST|PUT|PATCH|DELETE",code=~"4.."}[1h]))
          record: code_verb:apiserver_request_total:increase1h
        - expr: |
            sum by (cluster, code, verb) (increase(apiserver_request_total{job="apiserver",verb=~"LIST|GET|POST|PUT|PATCH|DELETE",code=~"5.."}[1h]))
          record: code_verb:apiserver_request_total:increase1h
    - name: k8s.rules
      rules:
        - expr: |
            sum by (cluster, namespace, pod, container) (
              irate(container_cpu_usage_seconds_total{job="kubelet", metrics_path="/metrics/cadvisor", image!=""}[5m])
            ) * on (cluster, namespace, pod) group_left(node) topk by (cluster, namespace, pod) (
              1, max by(cluster, namespace, pod, node) (kube_pod_info{node!=""})
            )
          record: node_namespace_pod_container:container_cpu_usage_seconds_total:sum_irate
        - expr: |
            container_memory_working_set_bytes{job="kubelet", metrics_path="/metrics/cadvisor", image!=""}
            * on (namespace, pod) group_left(node) topk by(namespace, pod) (1,
              max by(namespace, pod, node) (kube_pod_info{node!=""})
            )
          record: node_namespace_pod_container:container_memory_working_set_bytes
        - expr: |
            container_memory_rss{job="kubelet", metrics_path="/metrics/cadvisor", image!=""}
            * on (namespace, pod) group_left(node) topk by(namespace, pod) (1,
              max by(namespace, pod, node) (kube_pod_info{node!=""})
            )
          record: node_namespace_pod_container:container_memory_rss
        - expr: |
            container_memory_cache{job="kubelet", metrics_path="/metrics/cadvisor", image!=""}
            * on (namespace, pod) group_left(node) topk by(namespace, pod) (1,
              max by(namespace, pod, node) (kube_pod_info{node!=""})
            )
          record: node_namespace_pod_container:container_memory_cache
        - expr: |
            container_memory_swap{job="kubelet", metrics_path="/metrics/cadvisor", image!=""}
            * on (namespace, pod) group_left(node) topk by(namespace, pod) (1,
              max by(namespace, pod, node) (kube_pod_info{node!=""})
            )
          record: node_namespace_pod_container:container_memory_swap
        - expr: |
            kube_pod_container_resource_requests{resource="memory",job="kube-state-metrics"}  * on (namespace, pod, cluster)
            group_left() max by (namespace, pod) (
              (kube_pod_status_phase{phase=~"Pending|Running"} == 1)
            )
          record: cluster:namespace:pod_memory:active:kube_pod_container_resource_requests
        - expr: |
            sum by (namespace, cluster) (
                sum by (namespace, pod, cluster) (
                    max by (namespace, pod, container, cluster) (
                      kube_pod_container_resource_requests{resource="memory",job="kube-state-metrics"}
                    ) * on(namespace, pod, cluster) group_left() max by (namespace, pod, cluster) (
                      kube_pod_status_phase{phase=~"Pending|Running"} == 1
                    )
                )
            )
          record: namespace_memory:kube_pod_container_resource_requests:sum
        - expr: |
            kube_pod_container_resource_requests{resource="cpu",job="kube-state-metrics"}  * on (namespace, pod, cluster)
            group_left() max by (namespace, pod) (
              (kube_pod_status_phase{phase=~"Pending|Running"} == 1)
            )
          record: cluster:namespace:pod_cpu:active:kube_pod_container_resource_requests
        - expr: |
            sum by (namespace, cluster) (
                sum by (namespace, pod, cluster) (
                    max by (namespace, pod, container, cluster) (
                      kube_pod_container_resource_requests{resource="cpu",job="kube-state-metrics"}
                    ) * on(namespace, pod, cluster) group_left() max by (namespace, pod, cluster) (
                      kube_pod_status_phase{phase=~"Pending|Running"} == 1
                    )
                )
            )
          record: namespace_cpu:kube_pod_container_resource_requests:sum
        - expr: |
            kube_pod_container_resource_limits{resource="memory",job="kube-state-metrics"}  * on (namespace, pod, cluster)
            group_left() max by (namespace, pod) (
              (kube_pod_status_phase{phase=~"Pending|Running"} == 1)
            )
          record: cluster:namespace:pod_memory:active:kube_pod_container_resource_limits
        - expr: |
            sum by (namespace, cluster) (
                sum by (namespace, pod, cluster) (
                    max by (namespace, pod, container, cluster) (
                      kube_pod_container_resource_limits{resource="memory",job="kube-state-metrics"}
                    ) * on(namespace, pod, cluster) group_left() max by (namespace, pod, cluster) (
                      kube_pod_status_phase{phase=~"Pending|Running"} == 1
                    )
                )
            )
          record: namespace_memory:kube_pod_container_resource_limits:sum
        - expr: |
            kube_pod_container_resource_limits{resource="cpu",job="kube-state-metrics"}  * on (namespace, pod, cluster)
            group_left() max by (namespace, pod) (
             (kube_pod_status_phase{phase=~"Pending|Running"} == 1)
             )
          record: cluster:namespace:pod_cpu:active:kube_pod_container_resource_limits
        - expr: |
            sum by (namespace, cluster) (
                sum by (namespace, pod, cluster) (
                    max by (namespace, pod, container, cluster) (
                      kube_pod_container_resource_limits{resource="cpu",job="kube-state-metrics"}
                    ) * on(namespace, pod, cluster) group_left() max by (namespace, pod, cluster) (
                      kube_pod_status_phase{phase=~"Pending|Running"} == 1
                    )
                )
            )
          record: namespace_cpu:kube_pod_container_resource_limits:sum
        - expr: |
            max by (cluster, namespace, workload, pod) (
              label_replace(
                label_replace(
                  kube_pod_owner{job="kube-state-metrics", owner_kind="ReplicaSet"},
                  "replicaset", "$1", "owner_name", "(.*)"
                ) * on(replicaset, namespace) group_left(owner_name) topk by(replicaset, namespace) (
                  1, max by (replicaset, namespace, owner_name) (
                    kube_replicaset_owner{job="kube-state-metrics"}
                  )
                ),
                "workload", "$1", "owner_name", "(.*)"
              )
            )
          labels:
            workload_type: deployment
          record: namespace_workload_pod:kube_pod_owner:relabel
        - expr: |
            max by (cluster, namespace, workload, pod) (
              label_replace(
                kube_pod_owner{job="kube-state-metrics", owner_kind="DaemonSet"},
                "workload", "$1", "owner_name", "(.*)"
              )
            )
          labels:
            workload_type: daemonset
          record: namespace_workload_pod:kube_pod_owner:relabel
        - expr: |
            max by (cluster, namespace, workload, pod) (
              label_replace(
                kube_pod_owner{job="kube-state-metrics", owner_kind="StatefulSet"},
                "workload", "$1", "owner_name", "(.*)"
              )
            )
          labels:
            workload_type: statefulset
          record: namespace_workload_pod:kube_pod_owner:relabel
    - name: kube-scheduler.rules
      rules:
        - expr: |
            histogram_quantile(0.99, sum(rate(scheduler_e2e_scheduling_duration_seconds_bucket{job="kube-scheduler"}[5m])) without(instance, pod))
          labels:
            quantile: "0.99"
          record: cluster_quantile:scheduler_e2e_scheduling_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.99, sum(rate(scheduler_scheduling_algorithm_duration_seconds_bucket{job="kube-scheduler"}[5m])) without(instance, pod))
          labels:
            quantile: "0.99"
          record: cluster_quantile:scheduler_scheduling_algorithm_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.99, sum(rate(scheduler_binding_duration_seconds_bucket{job="kube-scheduler"}[5m])) without(instance, pod))
          labels:
            quantile: "0.99"
          record: cluster_quantile:scheduler_binding_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.9, sum(rate(scheduler_e2e_scheduling_duration_seconds_bucket{job="kube-scheduler"}[5m])) without(instance, pod))
          labels:
            quantile: "0.9"
          record: cluster_quantile:scheduler_e2e_scheduling_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.9, sum(rate(scheduler_scheduling_algorithm_duration_seconds_bucket{job="kube-scheduler"}[5m])) without(instance, pod))
          labels:
            quantile: "0.9"
          record: cluster_quantile:scheduler_scheduling_algorithm_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.9, sum(rate(scheduler_binding_duration_seconds_bucket{job="kube-scheduler"}[5m])) without(instance, pod))
          labels:
            quantile: "0.9"
          record: cluster_quantile:scheduler_binding_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.5, sum(rate(scheduler_e2e_scheduling_duration_seconds_bucket{job="kube-scheduler"}[5m])) without(instance, pod))
          labels:
            quantile: "0.5"
          record: cluster_quantile:scheduler_e2e_scheduling_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.5, sum(rate(scheduler_scheduling_algorithm_duration_seconds_bucket{job="kube-scheduler"}[5m])) without(instance, pod))
          labels:
            quantile: "0.5"
          record: cluster_quantile:scheduler_scheduling_algorithm_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.5, sum(rate(scheduler_binding_duration_seconds_bucket{job="kube-scheduler"}[5m])) without(instance, pod))
          labels:
            quantile: "0.5"
          record: cluster_quantile:scheduler_binding_duration_seconds:histogram_quantile
    - name: node.rules
      rules:
        - expr: |
            topk by(namespace, pod) (1,
              max by (node, namespace, pod) (
                label_replace(kube_pod_info{job="kube-state-metrics",node!=""}, "pod", "$1", "pod", "(.*)")
            ))
          record: "node_namespace_pod:kube_pod_info:"
        - expr: |
            count by (cluster, node) (sum by (node, cpu) (
              node_cpu_seconds_total{job="node-exporter"}
            * on (namespace, pod) group_left(node)
              topk by(namespace, pod) (1, node_namespace_pod:kube_pod_info:)
            ))
          record: node:node_num_cpu:sum
        - expr: |
            sum(
              node_memory_MemAvailable_bytes{job="node-exporter"} or
              (
                node_memory_Buffers_bytes{job="node-exporter"} +
                node_memory_Cached_bytes{job="node-exporter"} +
                node_memory_MemFree_bytes{job="node-exporter"} +
                node_memory_Slab_bytes{job="node-exporter"}
              )
            ) by (cluster)
          record: :node_memory_MemAvailable_bytes:sum
    - name: kubelet.rules
      rules:
        - expr: |
            histogram_quantile(0.99, sum(rate(kubelet_pleg_relist_duration_seconds_bucket[5m])) by (instance, le) * on(instance) group_left(node) kubelet_node_name{job="kubelet", metrics_path="/metrics"})
          labels:
            quantile: "0.99"
          record: node_quantile:kubelet_pleg_relist_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.9, sum(rate(kubelet_pleg_relist_duration_seconds_bucket[5m])) by (instance, le) * on(instance) group_left(node) kubelet_node_name{job="kubelet", metrics_path="/metrics"})
          labels:
            quantile: "0.9"
          record: node_quantile:kubelet_pleg_relist_duration_seconds:histogram_quantile
        - expr: |
            histogram_quantile(0.5, sum(rate(kubelet_pleg_relist_duration_seconds_bucket[5m])) by (instance, le) * on(instance) group_left(node) kubelet_node_name{job="kubelet", metrics_path="/metrics"})
          labels:
            quantile: "0.5"
          record: node_quantile:kubelet_pleg_relist_duration_seconds:histogram_quantile
